<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.54
     from r5rs.texi on 8 March 1998 -->

<TITLE>Revised(5) Report on the Algorithmic Language Scheme - Semantics</TITLE>
<link href="r5rs_6.html" rel=Next>
<link href="r5rs_4.html" rel=Previous>
<link href="r5rs_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="r5rs_1.html">first</A>, <A HREF="r5rs_4.html">previous</A>, <A HREF="r5rs_6.html">next</A>, <A HREF="r5rs_83.html">last</A> section, <A HREF="r5rs_toc.html">table of contents</A>.
<P><HR><P>


<H2><A NAME="SEC7" HREF="r5rs_toc.html#TOC7">1.1  Semantics</A></H2>

<P>
This section gives an overview of Scheme's semantics.  A detailed informal
semantics is the subject of chapters 3 through 6.  For reference purposes,
section 7.2 provides a formal semantics of Scheme.

</P>
<P>
Following Algol, Scheme is a statically scoped programming language.  Each use
of a variable is associated with a lexically apparent binding of that variable.

</P>
<P>
Scheme has latent as opposed to manifest types.  Types are associated with
values (also called objects) rather than with variables.  (Some authors refer
to languages with latent types as weakly typed or dynamically typed languages.)
Other languages with latent types are APL, Snobol, and other dialects of Lisp.
Languages with manifest types (sometimes referred to as strongly typed or
statically typed languages) include Algol 60, Pascal, and C.

</P>
<P>
All objects created in the course of a Scheme computation, including procedures
and continuations, have unlimited extent.  No Scheme object is ever destroyed.
The reason that implementations of Scheme do not (usually!) run out of storage
is that they are permitted to reclaim the storage occupied by an object if they
can prove that the object cannot possibly matter to any future computation.
Other languages in which most objects have unlimited extent include APL and
other Lisp dialects.

</P>
<P>
Implementations of Scheme are required to be properly tail-recursive.  This
allows the execution of an iterative computation in constant space, even if the
iterative computation is described by a syntactically recursive procedure.
Thus with a properly tail-recursive implementation, iteration can be expressed
using the ordinary procedure-call mechanics, so that special iteration
constructs are useful only as syntactic sugar.  See section 3.5.

</P>
<P>
Scheme procedures are objects in their own right.  Procedures can be created
dynamically, stored in data structures, returned as results of procedures, and
so on.  Other languages with these properties include Common Lisp and ML.

</P>
<P>
One distinguishing feature of Scheme is that continuations, which in most other
languages only operate behind the scenes, also have "first-class" status.
Continuations are useful for implementing a wide variety of advanced control
constructs, including non-local exits, backtracking, and coroutines.  See
section 6.4.

</P>
<P>
Arguments to Scheme procedures are always passed by value, which means that the
actual argument expressions are evaluated before the procedure gains control,
whether the procedure needs the result of the evaluation or not.  ML, C, and
APL are three other languages that always pass arguments by value.  This is
distinct from the lazy-evaluation semantics of Haskell, or the call-by-name
semantics of Algol 60, where an argument expression is not evaluated unless its
value is needed by the procedure.

</P>
<P>
Scheme's model of arithmetic is designed to remain as independent as possible
of the particular ways in which numbers are represented within a computer. In
Scheme, every integer is a rational number, every rational is a real, and every
real is a complex number.  Thus the distinction between integer and real
arithmetic, so important to many programming languages, does not appear in
Scheme.  In its place is a distinction between exact arithmetic, which
corresponds to the mathematical ideal, and inexact arithmetic on
approximations.  As in Common Lisp, exact arithmetic is not limited to
integers.

</P>
<P><HR><P>
<p>Go to the <A HREF="r5rs_1.html">first</A>, <A HREF="r5rs_4.html">previous</A>, <A HREF="r5rs_6.html">next</A>, <A HREF="r5rs_83.html">last</A> section, <A HREF="r5rs_toc.html">table of contents</A>.
</BODY>
</HTML>
