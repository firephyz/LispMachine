<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.54
     from r5rs.texi on 8 March 1998 -->

<TITLE>Revised(5) Report on the Algorithmic Language Scheme - Pattern language</TITLE>
<link href="r5rs_41.html" rel=Next>
<link href="r5rs_39.html" rel=Previous>
<link href="r5rs_toc.html" rel=ToC>

</HEAD>
<BODY>
<p>Go to the <A HREF="r5rs_1.html">first</A>, <A HREF="r5rs_39.html">previous</A>, <A HREF="r5rs_41.html">next</A>, <A HREF="r5rs_83.html">last</A> section, <A HREF="r5rs_toc.html">table of contents</A>.
<P><HR><P>


<H3><A NAME="SEC42" HREF="r5rs_toc.html#TOC42">4.3.2  Pattern language</A></H3>

<P>
A &#60;transformer spec&#62; has the following form:

</P>

<PRE>
  (syntax-rules &#60;literals&#62; &#60;syntax rule&#62; ...)
</PRE>

<P>
Syntax: &#60;Literals&#62; is a list of identifiers and each &#60;syntax rule&#62; should be of
the form

</P>

<PRE>
    (&#60;pattern&#62; &#60;template&#62;)
</PRE>

<P>
The &#60;pattern&#62; in a &#60;syntax rule&#62; is a list &#60;pattern&#62; that begins with the
keyword for the macro.

</P>
<P>
A &#60;pattern&#62; is either an identifier, a constant, or one of the following

</P>

<PRE>
  (&#60;pattern&#62; ...)
  (&#60;pattern&#62; &#60;pattern&#62; ... . &#60;pattern&#62;)
  (&#60;pattern&#62; ... &#60;pattern&#62; &#60;ellipsis&#62;)
  #(&#60;pattern&#62; ...)
  #(&#60;pattern&#62; ... &#60;pattern&#62; &#60;ellipsis&#62;)
</PRE>

<P>
and a template is either an identifier, a constant, or one of the following

</P>

<PRE>
  (&#60;element&#62; ...)
  (&#60;element&#62; &#60;element&#62; ... . &#60;template&#62;)
  #(&#60;element&#62; ...)
</PRE>

<P>
where an &#60;element&#62; is a &#60;template&#62; optionally followed by an &#60;ellipsis&#62; and an
&#60;ellipsis&#62; is the identifier "..." (which cannot be used as an identifier
in either a template or a pattern).

</P>
<P>
Semantics: An instance of syntax-rules produces a new macro transformer by
specifying a sequence of hygienic rewrite rules.  A use of a macro whose
keyword is associated with a transformer specified by syntax-rules is matched
against the patterns contained in the &#60;syntax rule&#62;s, beginning with the
leftmost &#60;syntax rule&#62;.  When a match is found, the macro use is transcribed
hygienically according to the template.

</P>
<P>
An identifier that appears in the pattern of a &#60;syntax rule&#62; is a pattern
variable, unless it is the keyword that begins the pattern, is listed in
&#60;literals&#62;, or is the identifier "...".  Pattern variables match arbitrary
input elements and are used to refer to elements of the input in the template.
It is an error for the same pattern variable to appear more than once in a
&#60;pattern&#62;.

</P>
<P>
The keyword at the beginning of the pattern in a &#60;syntax rule&#62; is not involved
in the matching and is not considered a pattern variable or literal identifier.

</P>
<P>
Rationale: The scope of the keyword is determined by the expression or syntax
definition that binds it to the associated macro transformer.  If the keyword
were a pattern variable or literal identifier, then the template that follows
the pattern would be within its scope regardless of whether the keyword were
bound by let-syntax or by letrec-syntax.

</P>
<P>
Identifiers that appear in &#60;literals&#62; are interpreted as literal identifiers to
be matched against corresponding subforms of the input.  A subform in the input
matches a literal identifier if and only if it is an identifier and either both
its occurrence in the macro expression and its occurrence in the macro
definition have the same lexical binding, or the two identifiers are equal and
both have no lexical binding.

</P>
<P>
A subpattern followed by ... can match zero or more elements of the input.
It is an error for ... to appear in &#60;literals&#62;.  Within a pattern the
identifier ... must follow the last element of a nonempty sequence of
subpatterns.

</P>
<P>
More formally, an input form F matches a pattern P if and only if:

</P>

<UL>

<LI>

P is a non-literal identifier; or

<LI>

P is a literal identifier and F is an identifier with the same binding; or

<LI>

P is a list (P1 ... Pn) and F is a list of n forms that match P1 through
Pn, respectively; or

<LI>

P is an improper list (P1 P2 ... Pn . Pn+1) and F is a list or improper
list of n or more forms that match P1 through Pn, respectively, and whose nth
"cdr" matches Pn+1; or

<LI>

P is of the form (P1 ... Pn Pn1 &#60;ellipsis&#62;) where &#60;ellipsis&#62; is the
identifier ... and F is a proper list of at least n forms, the first n of
which match P1 through Pn, respectively, and each remaining element of F
matches Pn+1; or

<LI>

P is a vector of the form #(P1 ... Pn) and F is a vector of n forms that
match P1 through Pn; or

<LI>

P is of the form #(P1 ... Pn Pn+1 &#60;ellipsis&#62;) where &#60;ellipsis&#62; is the
identifier ... and F is a vector of n or more forms the first n of which
match P1 through Pn, respectively, and each remaining element of F matches
Pn+1; or

<LI>

P is a datum and F is equal to P in the sense of the equal? procedure.

</UL>

<P>
It is an error to use a macro keyword, within the scope of its binding, in an
expression that does not match any of the patterns.

</P>
<P>
When a macro use is transcribed according to the template of the matching
&#60;syntax rule&#62;, pattern variables that occur in the template are replaced by
the subforms they match in the input.  Pattern variables that occur in
subpatterns followed by one or more instances of the identifier ... are
allowed only in subtemplates that are followed by as many instances of
....  They are replaced in the output by all of the subforms they
match in the input, distributed as indicated.  It is an error if the output
cannot be built up as specified.

</P>
<P>
Identifiers that appear in the template but are not pattern variables or the
identifier ... are inserted into the output as literal identifiers.  If a
literal identifier is inserted as a free identifier then it refers to the
binding of that identifier within whose scope the instance of syntax-rules
appears.  If a literal identifier is inserted as a bound identifier then it is
in effect renamed to prevent inadvertent captures of free identifiers.

</P>
<P>
As an example, if let and cond are defined as in section 7.3 then they are
hygienic (as required) and the following is not an error.

</P>

<PRE>
  (let ((=&#62; #f))
    (cond (#t =&#62; 'ok)))           => ok
</PRE>

<P>
The macro transformer for cond recognizes =&#62; as a local variable, and hence an
expression, and not as the top-level identifier =&#62;, which the macro transformer
treats as a syntactic keyword.  Thus the example expands into

</P>

<PRE>
  (let ((=&#62; #f))
    (if #t (begin =&#62; 'ok)))
</PRE>

<P>
instead of

</P>

<PRE>
  (let ((=&#62; #f))
    (let ((temp #t))
      (if temp ('ok temp))))
</PRE>

<P>
which would result in an invalid procedure call.

</P>
<P><HR><P>
<p>Go to the <A HREF="r5rs_1.html">first</A>, <A HREF="r5rs_39.html">previous</A>, <A HREF="r5rs_41.html">next</A>, <A HREF="r5rs_83.html">last</A> section, <A HREF="r5rs_toc.html">table of contents</A>.
</BODY>
</HTML>
